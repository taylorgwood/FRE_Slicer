#include "gcode.h"

Gcode::Gcode()
{

}

void Gcode::generate_file(Shape& shape, std::string fileName)
{
    //    set_shape(shape);
    set_file_name(fileName);
    std::ofstream fout = create_empty_file();
    write_gcode(fout, shape);
    fout.close();
}

void Gcode::write_gcode(std::ofstream& fout, Shape& shape)
{
    write_initial_gcode(fout);
    int numberOfLayers = shape.get_number_of_layers();
    for (int i{0}; i<numberOfLayers; i++)
    {
        int layerNumber{i};
        fout << "; Beginning layer: " << layerNumber << std::endl;
        Layer* layer = shape.get_layer(layerNumber);
        write_layer_gcode(fout, layer);
    }
}

std::ofstream Gcode::create_empty_file()
{
    std::string completeFileName = make_file_name_unique();
    set_file_name(completeFileName);
    std::ofstream fout = get_fout();
    return fout;
}

std::ofstream Gcode::get_fout()
{
    std::string fileName = get_file_name();
    std::ofstream fout{fileName};
    if (fout.fail())
    {
        std::cout << "Failed to write to file." << std::endl;
    }
    return fout;
}

std::string Gcode::make_file_name_unique()
{
    std::string suffix = ".txt";
    std::string fileName = get_file_name();
    std::string completeFileName = fileName + suffix;
    int incrementCount{1};
    while(does_file_exist(completeFileName))
    {
        std::string incrementText = std::to_string(incrementCount);
        completeFileName = fileName + incrementText + suffix;
        incrementCount++;
    }
    return completeFileName;
}

bool Gcode::does_file_exist(const std::string& completeFileName)
{
    struct stat buf;
    if (stat(completeFileName.c_str(), &buf) != -1)
    {
        return true;
    }
    return false;
}

std::string Gcode::get_file_name() const
{
    return mFileName;
}

void Gcode::set_file_name(std::string const fileName)
{
    mFileName = fileName;
}

void Gcode::write_layer_gcode(std::ofstream&  fout, Layer* layer)
{
    double zLocation = layer->get_location();
    fout << "G1 " << " Z" << zLocation;
    fout << " F1200.000" << std::endl;

    write_points_in_layer(fout, layer);
}

void Gcode::write_points_in_layer(std::ofstream& fout, Layer* layer)
{
    std::vector<Path*> pathsInLayer = layer->get_path_list();
    size_t numberOfPathsInLayer = layer->get_number_of_paths();
    for (int i{0}; i<numberOfPathsInLayer; i++)
    {
        Path* path = pathsInLayer[i];
        write_points_in_path(fout, path);
    }
}

void Gcode::write_initial_gcode(std::ofstream& fout)
{
    //    fout << "File created: " << std::endl;
    fout << "Gcode generated by FRE_Slicer." << std::endl;
    fout << std::endl;

    fout << "G28 ; home all axes" << std::endl;
    fout << "G21 ; set units to millimeters" << std::endl;
    fout << "G90 ; use absolute coordinates" << std::endl;
    fout << std::endl;
}


void Gcode::write_points_in_path(std::ofstream& fout, Path* path)
{
    double diameter = path->get_diameter();
    std::vector<Point*> pointsInPath = path->get_point_list();
    size_t numberOfPointsInPath = path->get_number_of_points();
    for (int i{0}; i<numberOfPointsInPath; i++)
    {
        Point* point = pointsInPath[i];
        fout << "G1 ";
        fout << " X" << point->get_x();
        fout << " Y" << point->get_y();
        double materialRatio = point->get_material();
        double extrusionDistance = get_extrusion_distance(diameter, path, i);
        increment_extruder_A_displacement(materialRatio*extrusionDistance);
        increment_extruder_B_displacement((1-materialRatio)*extrusionDistance);
        double extruderADisplacement = get_extruder_A_displacement();
        double extruderBDisplacement = get_extruder_B_displacement();
        fout << " A" << extruderADisplacement;
        fout << " B" << extruderBDisplacement;
        fout << std::endl;
        mPointCount += 1;
    }
}

double Gcode::get_extrusion_distance(double diameter, Path* path, int pointCount)
{
    double printCrossSectionalArea = pi*(diameter*diameter)/4;
    double printLength = calculate_length(path, pointCount);
    double printVolume = printCrossSectionalArea*printLength;
    double extrusionDistance = printVolume/mSyringeCrossSectionalArea;
    return extrusionDistance;
}

double Gcode::get_extruder_A_displacement() const
{
    return mExtruderADisplacement;
}

double Gcode::get_extruder_B_displacement() const
{
    return mExtruderBDisplacement;
}

void Gcode::increment_extruder_A_displacement(double extruderAStep)
{
    mExtruderADisplacement += extruderAStep;
}

void Gcode::increment_extruder_B_displacement(double extruderBStep)
{
    mExtruderBDisplacement += extruderBStep;
}

double Gcode::calculate_length(Path* path, int pointCount)
{
    double length{0};
    std::vector<Point*> pointsInPath = path->get_point_list();
    size_t numberOfPointsInPath = path->get_number_of_points();
    if (pointCount != 0)
    {
    Point* previousPoint = pointsInPath[pointCount-1];
    Point* currentPoint = pointsInPath[pointCount];
    Point lengthVector = *currentPoint - *previousPoint;
    length = lengthVector.get_magnitude();
    }
    return length;
}

// delete file function
//
