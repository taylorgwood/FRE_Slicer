#include "gcode.h"

Gcode::Gcode()
{

}

void Gcode::generate_file(Shape& shape)
{
    std::ofstream fout = create_empty_file();
    write_gcode(fout, shape);
    fout.close();
}

void Gcode::write_gcode(std::ofstream& fout, Shape& shape)
{
    write_initial_gcode(fout, shape);
    int numberOfLayers = shape.get_number_of_layers();
    for (int i{0}; i<numberOfLayers; i++)
    {
        int layerNumber{i};
        fout << "; Beginning layer: " << layerNumber << std::endl;
        write_layer_gcode(fout, shape, layerNumber);
    }

}

std::ofstream Gcode::create_empty_file()
{
    make_file_name_unique();
    std::string fileName = get_file_name();
    std::ofstream fout{fileName};
    if (fout.fail())
    {
        std::cout << "Failed to write to file." << std::endl;
    }
    return fout;
}

void Gcode::make_file_name_unique()
{
    std::string fileName = get_file_name();

    if (does_file_exist(fileName))
    {
        std::string suffix = "(1)";
        fileName = fileName + suffix;
    }

    set_file_name(fileName);
}

bool Gcode::does_file_exist(const std::string& fileName)
{
    struct stat buf;
    if (stat(fileName.c_str(), &buf) != -1)
    {
        return true;
    }
    return false;
}

std::string Gcode::get_file_name() const
{
    return mFileName;
}

void Gcode::set_file_name(std::string const fileName)
{
    mFileName = fileName;
}

void Gcode::write_layer_gcode(std::ofstream& fout, Shape& shape, int layerNumber)
{
    Layer* layer = shape.get_layer(layerNumber);

    double zLocation = layer->get_location();
    fout << "G1 " << "Z" << zLocation;
    fout << " F1200.000" << std::endl;

    write_points_in_layer(fout,layer);
}

void Gcode::write_points_in_layer(std::ofstream& fout, Layer* layer)
{
    std::vector<Path*> pathsInLayer = layer->get_path_list();
    size_t numberOfPathsInLayer = layer->get_number_of_paths();
    for (int i{0}; i<numberOfPathsInLayer; i++)
    {
        Path* path = pathsInLayer[i];
        write_points_in_path(fout,path);
    }
    Path* path = pathsInLayer[0];

}

void Gcode::write_initial_gcode(std::ofstream& fout, Shape& shape)
{
    //    fout << "File created: " << std::endl;
    fout << "Gcode generated by FRE_Slicer." << std::endl;
    fout << std::endl;

    fout << "G28 ; home all axes" << std::endl;
    fout << "G21 ; set units to millimeters" << std::endl;
    fout << "G90 ; use absolute coordinates" << std::endl;
    fout << std::endl;
}


void Gcode::write_points_in_path(std::ofstream& fout, Path* path)
{
    double diameter = path->get_diameter();
    std::vector<Point*> pointsInPath = path->get_point_list();
    size_t numberOfPointsInPath = path->get_number_of_points();
    for (int i{0}; i<numberOfPointsInPath; i++)
    {
        Point* point = pointsInPath[i];
        fout << "G1 ";
        fout << " X" << point->get_x();
        fout << " Y" << point->get_y();
        double materialRatio = point->get_material();
        double extrusionDistance = get_extrusion_distance(diameter,mPointCount);
        increment_extruder_A_displacement(materialRatio*extrusionDistance);
        increment_extruder_B_displacement((1-materialRatio)*extrusionDistance);
        double extruderADisplacement = get_extruder_A_displacement();
        double extruderBDisplacement = get_extruder_B_displacement();
        fout << " A" << extruderADisplacement;
        fout << " B" << extruderBDisplacement;
        fout << std::endl;
        mPointCount += 1;
    }
}

double Gcode::get_extrusion_distance(double diameter, double mPointCount)
{
    double printCrossSectionalArea = pi*(diameter*diameter)/4;
    double printLength = 1; // change this
    double printVolume = printCrossSectionalArea*printLength;
    double extrusionDistance = printVolume/mSyringeCrossSectionalArea;
    return extrusionDistance;
}

double Gcode::get_extruder_A_displacement() const
{
    return mExtruderADisplacement;
}

double Gcode::get_extruder_B_displacement() const
{
    return mExtruderBDisplacement;
}

void Gcode::increment_extruder_A_displacement(double extruderAStep)
{
    mExtruderADisplacement += extruderAStep;
}

void Gcode::increment_extruder_B_displacement(double extruderBStep)
{
    mExtruderBDisplacement += extruderBStep;
}
